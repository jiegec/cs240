diff --git a/.vscode/settings.json b/.vscode/settings.json
index e69de29..f5d622f 100644
--- a/.vscode/settings.json
+++ b/.vscode/settings.json
@@ -0,0 +1,3 @@
+{
+    "cquery.cacheDirectory": "${workspaceFolder}/.vscode/cquery_cached_index/"
+}
\ No newline at end of file
diff --git a/compile_commands.json b/compile_commands.json
index e69de29..db9257d 100644
--- a/compile_commands.json
+++ b/compile_commands.json
@@ -0,0 +1,36 @@
+[
+ {
+  "directory": "/Volumes/Data/cs240/lab1", 
+  "arguments": [
+   "cc", 
+   "-Wall", 
+   "-Wextra", 
+   "-Werror", 
+   "-Wswitch-default", 
+   "-Wwrite-strings", 
+   "-Iinclude", 
+   "-Itest/include", 
+   "-std=gnu99", 
+   "-c", 
+   "src/main.c"
+  ], 
+  "file": "src/main.c"
+ }, 
+ {
+  "directory": "/Volumes/Data/cs240/lab1", 
+  "arguments": [
+   "cc", 
+   "-Wall", 
+   "-Wextra", 
+   "-Werror", 
+   "-Wswitch-default", 
+   "-Wwrite-strings", 
+   "-Iinclude", 
+   "-Itest/include", 
+   "-std=gnu99", 
+   "-c", 
+   "src/thread.c"
+  ], 
+  "file": "src/thread.c"
+ }
+]
diff --git a/src/thread.c b/src/thread.c
index 4b51405..b081a8d 100644
--- a/src/thread.c
+++ b/src/thread.c
@@ -31,7 +31,7 @@ int64_t atomic_next_id() {
  *
  * @param thread the thread to add to the linked list; must be non-null
  */
-void add_thread(grn_thread *thread) {
+void add_thread(grn_thread* thread) {
   assert(thread);
   if (STATE.threads) {
     STATE.threads->prev = thread;
@@ -48,7 +48,7 @@ void add_thread(grn_thread *thread) {
  *
  * @param thread the thread being removed from linked list; must be non-null
  */
-void remove_thread(grn_thread *thread) {
+void remove_thread(grn_thread* thread) {
   assert(thread);
   if (STATE.threads == thread) {
     STATE.threads = thread->next;
@@ -73,7 +73,7 @@ void remove_thread(grn_thread *thread) {
  *
  * @return a pointer to the thread after `thread`
  */
-grn_thread *next_thread(grn_thread *thread) {
+grn_thread* next_thread(grn_thread* thread) {
   assert(thread);
   return (thread->next) ? thread->next : STATE.threads;
 }
@@ -91,11 +91,21 @@ grn_thread *next_thread(grn_thread *thread) {
  *
  * @return a pointer to the newly allocated grn_thread structure
  */
-grn_thread *grn_new_thread(bool alloc_stack) {
-  UNUSED(alloc_stack);
-
+grn_thread* grn_new_thread(bool alloc_stack) {
   // FIXME: Allocate a new thread and stack.
-  return NULL;
+  grn_thread* thread = (grn_thread*)malloc(sizeof(grn_thread));
+  assert(thread);
+
+  memset(&thread->context, 0, sizeof(thread->context));
+  thread->id = atomic_next_id();
+  thread->status = WAITING;
+  add_thread(thread);
+
+  if (alloc_stack) {
+    posix_memalign((void**)&thread->stack, 16, STACK_SIZE);
+  }
+
+  return thread;
 }
 
 /**
@@ -104,10 +114,16 @@ grn_thread *grn_new_thread(bool alloc_stack) {
  *
  * @param thread the thread to deallocate and remove from linked list
  */
-void grn_destroy_thread(grn_thread *thread) {
-  UNUSED(thread);
-
+void grn_destroy_thread(grn_thread* thread) {
   // FIXME: Free the resources used by `thread`.
+  remove_thread(thread);
+
+  if (thread->stack) {
+    free(thread->stack);
+    thread->stack = NULL;
+  }
+
+  free(thread);
 }
 
 /**
@@ -115,14 +131,23 @@ void grn_destroy_thread(grn_thread *thread) {
  *
  * @param thread the thread to debug pretty-print
  */
-void debug_thread_print(grn_thread *thread) {
-  const char *status;
+void debug_thread_print(grn_thread* thread) {
+  const char* status;
   switch (thread->status) {
-    case WAITING: status = "WAITING"; break;
-    case READY: status = "READY"; break;
-    case RUNNING: status = "RUNNING"; break;
-    case ZOMBIE: status = "ZOMBIE"; break;
-    default: status = "UNKNOWN";
+    case WAITING:
+      status = "WAITING";
+      break;
+    case READY:
+      status = "READY";
+      break;
+    case RUNNING:
+      status = "RUNNING";
+      break;
+    case ZOMBIE:
+      status = "ZOMBIE";
+      break;
+    default:
+      status = "UNKNOWN";
   }
 
   fprintf(stderr, ":: Thread ID:\t %" PRId64 "\n", thread->id);
